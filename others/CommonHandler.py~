'''
This is Cluster.py

by Elalic, 2011.08.14
'''
import pickle
import time
import SocketServer
import ThreadPoolMixIn 
import Message
import Client
import thread
import threading
from CommonServer import CommonServer

'''
      +---------------+
      | CommonHandler |
      +---------------+
        |      +----------+
        |----> | Cloud.py |
        |      +----------+
        |      +------------+
        |----> | Cluster.py |
        |      +------------+
        |      +---------+
        |----> | Rack.py |
        |      +---------+
        |      +---------+
        |----> | Node.py |
               +---------+

     +-----------------------------------------------------------------------------------+
     | Important:                                                                        |
     |    Launching each handler script NEED give host and port of server as parameter   |
     |    ex: python Cloud.py 140.112.123.234 7003                                       |
     +-----------------------------------------------------------------------------------+
      
     CommonHandler
     -- Main Working Handlers() (ex: GetAvaribleVM blah blah )
         Job: Recv Dispatched Req and Doing Main Work and return response

     -- reqDispatchDict dictionary
         Job: ReqClassName as key, "Main Working Handlers" binding functions as Value

     -- RequestDispatchHandler Class
         Job: use self.reqDispatchDict to dispatch req to main working handlers 

     -- run()
         Job: Instanciate Server(RequestDispatchHandler), and Server.serve_forever()
     
     -- Server         
        -- RequestHandler Class
             Job: Dispatch each Req to its own Handler Function
        -- main thread
             Job: init other threads and wait shutdown signal
        -- collect thread
             Job: collect imcoming requests and put into Queue
        -- threads in Pool
             Job: Use !RequestHandler, and run actual handler function

'''

class CommonHandler():
    CFGNAME_GLOBALFILE = 'default_cfg'
    def __init__(self, host, port):
        self.LoadCfg()
        self.cfg.host = host
        self.cfg.port = int(port)
        self.dispatch_handlers= { 'BlockingReq': self.Blocking,
                                  'CommandReq': self.CommandHandler, }
        self.startup_functions= list() 
        
    def run(self):
        self.address = ('', self.cfg.port)
        self.server = CommonServer(self.address, self.cfg.numServerThreads, RequestDispatchHandler, \
                      self.dispatch_handlers, self.startup_functions)
        self.server.serve_forever()

    class Config():
        pass

    def LoadCfg(self): # 
        ''' Global in default '''
        cfg_dict = dict()
        cfg_pathname = self.CFGNAME_GLOBALFILE
        execfile(cfg_pathname, cfg_dict)
        ''' Local in specific file'''
        my_cfg_dict = dict()
        my_cfg_pathname = self.CFGNAME_LOCALFILE
        execfile(my_cfg_pathname, my_cfg_dict)
        ''' Let local override global '''
        for k in my_cfg_dict.keys():
            cfg_dict[k] = my_cfg_dict[k]
        ''' clean up '''
        del cfg_dict['__builtins__']
        
        #for now, we only set the very needed cfg value, other settings can leave until used.
        self.cfg = CommonHandler.Config()
        self.cfg.rest = cfg_dict
        self.cfg.numServerThreads = int( cfg_dict.get( self.CFGNAME_numServerThreads ))
        self.cfg.name = ''
        self.cfg.parent_addr = ''
        self.cfg.children_addrs = list()

    def SetCfg(self, cfg_dict): 
        ''' Problem! 
                There is a issue, during a request's live period, there may exists inconsistent cfg problems after run SetCfg() method
            Solution:
                Each request copy a duplicate cfg before request start
        '''
        self.cfg.rest.update(cfg_dict)
        self.cfg.name = cfg_dict.get('name', self.cfg.name)
        self.cfg.parent_addr = cfg_dict.get('parent_addr', self.cfg.parent_addr )
        self.cfg.children_addrs = cfg_dict.get('children_addrs', self.cfg.children_addrs )
        if cfg_dict.has_key('numServerThreads'):
            self.cfg.numServerThreads = cfg_dict['numServerThreads']
            self.resizePool(self.cfg.numServerThreads)
    def resizePool(self):
        #implement in the future
        pass

    def Blocking(self, req):
        import time
        time.sleep(req.interval)
        return Message.BlockingRes()
    def CommandPeriodlyPing(self, interval, **karg):
        while True:
            ping_req = Message.CommandGetPingReq( target_address=( 'localhost', 7004 ), ping_times=4 ) 
            cmd_req = Message.CommandReq( CommandName="GetPing", CommandObject=ping_req)
            res = self.reqDispatchDict['CommandReq']( cmd_req )
            print( res.msg )

            time.sleep(interval)

    def CommandHandler(self, CommandReq):
        '''
            Command Input Format is
                req.CommandName : Dispatch Using
                req.CommandObject : Real Command

            Command Return Format is
                ( isSuccess(Bool), msg(String), optional object(Message) )
        '''
        CommandDispatcher = {
                'Shutdown': self.CommandShutdown,
                'Terminal': self.CommandTerminal,
                'SetRelation': self.CommandSetRelation,
                'GetPing': self.CommandPing,
                'Ping': self.CommandPong,
        }
        # print("CommandHandler method()")
        # print("CommandName: %s, CommandObject: %s" % ( CommandReq.CommandName, CommandReq.CommandObject.__class__.__name__ ) )
        try:
            isSuccess, msg, obj = CommandDispatcher[ CommandReq.CommandName ]( CommandReq.CommandObject )
            return Message.CommandRes(CommandName=CommandReq.CommandName, isSuccess=isSuccess, msg=msg, obj=obj)
        except KeyError as e:
            return Message.CommandRes(CommandName=CommandReq.CommandName, isSuccess=False, msg='Unregonized Command Name', obj=None)
        except Exception as e:
            return Message.CommandRes(CommandName=CommandReq.CommandName, isSuccess=False, msg='Exception occur: %s' % e, obj=None)


    def CommandSetRelation(self, obj ):
        relation = obj
        try :
            self.SetCfg( {'name':obj.name, 'host':obj.host, 'port':obj.port, 
                         'parent_addr':obj.parent_addr, 'children_addrs':obj.children_addrs } )
            return ( True, '', None )
        except Exception as e :
            return ( False, "%s" % e, None)
    def CommandPing(self, obj):
        ''' Receive Command to Ping others, then collect the ping status and send back to admin '''
        print("in CommandPing() method")
        req = obj
        try :
            import time
            target_address = req.target_address
            ping_times = 4 if req.ping_times == None else req.ping_times
            
            # Announce I am start pingping
            response = "Server@%s:%s is Pinging %s:%s...\n" % \
                       (self.cfg.host, self.cfg.port, \
                        target_address[0], target_address[1] )
            # Ping for #ping_times times
            for i in xrange( ping_times ):
                ping_req = Message.Ping(from_addr=(self.cfg.host, self.cfg.port), dest_addr=target_address)
                cmd_req = Message.CommandReq( CommandName="Ping", CommandObject=ping_req )
                
                # Calculate Response Time
                start_time = time.clock()
                
                pong_req = Client.send_message(target_address, cmd_req)
                time_val = time.clock() - start_time
                
                if pong_req.__class__.__name__ == 'Error' :
                    now_response = "Failed to receive from %s:%s" % ( target_address[0], target_address[1] ) 
                else:
                    # Collect Messages
                    now_response = "Receive Pong from %s:%s in %4.4f secs" % \
                                ( target_address[0], target_address[1], \
                                  time_val )

                print( now_response + '\n>' ),
                response += now_response + '\n'
            return ( True, response, None )
        except Exception as e:
            return ( False, "%s" % e , None )
    def CommandPong(self, req):
        # do nothing, class create for dict_map
        print("Recevie Pinging from %s:%s, now Pong back!\n>" % (req.from_addr[0], req.from_addr[1] ) ),
        return (True, '', None )
    def CommandShutdown(self, req):
        # (server.__shutdown_request.set(), wait other requests completed then server can shutdown)
        try:
            print("CommandShutdown() method call shutdown")
            self.server.shutdown()
            return ( True, 'server::shutdown() Called', None )
        except Exception as e :
            return ( False, '%s'%e, None )
    def CommandTerminal(self, req):
        try:
            print("CommandTerminal() method call shutdown and set timeout=0")
            self.server.shutdown_timeout = 0
            self.server.shutdown()
            return (True, 'Timeout setted 0, then server::shutdown() called', None )
        except Exception as e :
            return (False, '%s'%e, None )

class RequestDispatchHandler(SocketServer.BaseRequestHandler):
    def __init__(self, request, client_address, server, reqDispatchDict):
        self.reqDispatchDict = reqDispatchDict
        SocketServer.BaseRequestHandler.__init__(self, request, client_address, server)

    def handle(self):
        ''' Dispatch Every Request to its own Handler by reqDispatchDic[key(reqName)]=value(reqObj) '''
        # Recv Full-length Serial Data
        data = ""
        input = True
        while input:
            input = self.request.recv(4096)
            data += input
        
        try:
            # Convert Serial Data to Object
            recvobj = pickle.loads(data)
#            print("In handle() Recv a recvobj named %s " % recvobj.__class__.__name__ )
            # Perform Request
            my_thread = threading.current_thread()
            my_name =  my_thread.name
            my_thread.name = (my_name+" handling %s " % recvobj.__class__.__name__ )
            ret = self.reqDispatchDict[recvobj.__class__.__name__](recvobj) 
            my_thread.name = my_name
            self.request.send(pickle.dumps(ret))
        
        except pickle.UnpicklingError:
            error_req = Message.Error(msg='Unregonized Serial Data. Can not unpick it. Data Length: %d' % len(data) )
            self.request.send(pickle.dumps( error_req ) )

        except KeyError:
            error_req = Message.Error(msg='Unacceptable Request Name(Not in DispatchDict). Request Name %s' % recvobj.__class__.__name__ )
            self.request.send(pickle.dumps( error_req ) )

