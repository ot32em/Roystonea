## {{{ http://code.activestate.com/recipes/574454/ (r2)
from SocketServer import ThreadingMixIn, TCPServer
from Queue import Queue
import threading, socket
from threading import Event
import Message
from time import sleep

class CommonServer(TCPServer):
    '''
    use a thread pool instead of a new thread on every request
    '''
    #can be override
    numThreads = 4
    allow_reuse_address = True  # seems to fix socket.error on server restart

    def __init__(self, server_address, numServerThreads, RequestDispatchHandler, reqDispatchDict, pollingHandlerList=list() ):
        TCPServer.__init__(self, server_address, RequestDispatchHandler)
        self.request_queue_size = numServerThreads
        self.numThreads = numServerThreads
        self.reqDispatchDict = reqDispatchDict
        self.pollingHandlerList = pollingHandlerList

        self.threads = list()
        self.requests = Queue(self.numThreads)
        self.shutdown_timeout = 10

    def list_threads(self):
        print("numProcessingRequestThreads: %d" % self.numProcessingRequestThreads ) 
        print("__is_thread_call_shutdown isSet: %s" % self.__is_thread_call_shutdown.is_set() ) 
        for t in self.threads :
            print("%s is alive: %s" % ( t.getName(), t.isAlive() ) )

    def assign_thread_job(self, method, name=""):
        t = threading.Thread(target=method, name=name)
        t.setDaemon(True)
        self.threads.append(t)
        t.start()

    def serve_forever(self):
        # init event 
        self.numProcessingRequestThreads = 0 
        self.__is_thread_call_shutdown = Event()
        self.__check_thread_complete = Event()

        for x in range(self.numThreads):
            self.assign_thread_job( method=self.process_request_thread, \
                                    name="RequestHandleThread no.%d" % (x+1))
        for func in self.startup_functions:
            self.assign_thread_job( method=func , name="StartupFunctionThread '%s'" % ( func.__name__) ) 
        
        self.assign_thread_job( method=self.collect_requests, name="CollectRequestsThread")
        self.assign_thread_job( method=self.cmd_typing, name="CommandTypingThread")
       
        '''
            Folling Steps Handle the Shutdown Action
        '''
        # wait another thread
        self.__is_thread_call_shutdown.wait()
        
        # wait all request done its jobs
        timer = 0
        isTimeout = False
        while self.numProcessingRequestThreads > 0 :
            sleep(1)
            timer += 1
            if timer > self.shutdown_timeout :
                isTimeout = True
                break
            print("Wait NumProcessingRequestThreads: %d is 0, timeout: %d secs, remaining: %d secs " %
                    ( self.numProcessingRequestThreads, self.shutdown_timeout, self.shutdown_timeout-timer))
        if isTimeout :
            print("Because of timeout, force to terminal uncompleted request")
        else :
            print("All Requests has been completed")
        print("Shutting Down!")
        self.server_close()
    
    def shutdown(self):
        self.__is_thread_call_shutdown.set()

    def collect_requests(self):
        while True:
            self.handle_request() # collect every requests incomming and put it in queue
                                  # then, let thread in pool to pick them up to handle
    def handle_request(self):
        try:
            request, client_address = self.get_request()
        except socket.error:
            return
        if self.verify_request(request, client_address):
            self.requests.put((request, client_address))


    def cmd_typing(self):
        while True :
            try: 
                cmd = raw_input('>') 
                # shutdown
                if cmd.lower() in ( 'shutdown', 'exit', 'bye', 'stop' )  :
                    self.shutdown()
                if cmd.lower().split(' ')[0] in ( 'ping' ) :
                    argv = cmd.lower().split(' ')
                    if len(argv) > 2 :
                        host = argv[1]
                        port = int( argv[2] )
                        pingreq = Message.CommandPingReq( target_address=(host,port), ping_times=4)
                        cmdreq = Message.CommandReq(CommandName='GetPing', CommandObject = pingreq )
                        
                        res = self.reqDispatchDict['CommandReq']( cmdreq) 
                        print(" name: %s, isSuccess: %s, msg: %s " % ( res.__class__.__name__, res.isSuccess, res.msg )  )
                if cmd.lower() in ( 'list threads', 'list' ) :
                   self.list_threads()
                if cmd.lower().split(' ')[0] in ( '!', 'cmd' ) :
                    cmd_string = ' '.join( cmd.split(' ')[1:]) # skip first prompt
                    print("cmd_string: %s" % cmd_string )
                    if len( cmd_string.strip() ) > 0 :
                        try:
                            exec( cmd_string, globals() )
                        except Exception as e :
                            print("Running '%s' occurs Error, msg: %s" % e)
            except KeyError as e:
                print("Key Error: %s" % e)
            except Exception as e :
                print( "%s" % e ) 


    
    def process_request_thread(self):
        while True and self.__is_thread_call_shutdown.is_set() == False: 
            request, child_address = self.requests.get()
            try:
                self.finish_request( request, child_address )
            except Exception:
                self.handle_error( request, child_address )
            finally:
                self.shutdown_request( request )

    def finish_request(self, request, client_address):
        self.numProcessingRequestThreads += 1
        self.RequestHandlerClass(request, client_address, self, self.reqDispatchDict)
        self.numProcessingRequestThreads -= 1
        self.__check_thread_complete.set()


   
